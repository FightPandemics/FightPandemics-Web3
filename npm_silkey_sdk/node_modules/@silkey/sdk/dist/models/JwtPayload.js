"use strict";
/**
 * @module JwtPayload
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwtPayload = void 0;
const helpers_1 = require("../utils/helpers");
const settings_1 = require("../config/settings"); // do not change path!
const { SCOPE_DIVIDER } = settings_1.settings.ssoParams;
/**
 * @typedef JwtPayload
 * @type {object}
 * @property {string} email - verified email of the user,
 *  IMPORTANT: if email in user profile is different, you should always update it with this one.
 * @property {string} address - ID of the user, this is also valid ethereum address, use this to identify user
 * @property {string} userSignature - proof that request came from the user
 * @property {number} userSignatureTimestamp - time when signature was crated
 * @property {string} silkeySignature - proof that Silkey verified the email
 * @property {number} silkeySignatureTimestamp - time when signature was crated
 * @property {string} scope
 * @property {boolean} migration - if user started migration to Silkey, this will be true
 */
class JwtPayload {
    constructor() {
        this.email = '';
        this.scope = '';
        this.address = '';
        this.silkeySignatureTimestamp = 0;
        this.silkeySignature = '';
        this.userSignatureTimestamp = 0;
        this.userSignature = '';
        this.migration = false;
        this.getScope = () => this.scope.split(SCOPE_DIVIDER);
        this.setMigration = (status) => {
            this.migration = status;
            return this;
        };
        this.setScope = (scope) => {
            if (!scope) {
                return this;
            }
            if (!this.scope) {
                this.scope = scope;
                return this;
            }
            const map = {};
            const str = `${this.scope}${SCOPE_DIVIDER}${scope}`;
            str.split(SCOPE_DIVIDER).filter(k => !!k).forEach(k => {
                map[k] = k;
            });
            this.scope = Object.keys(map).sort().join(SCOPE_DIVIDER);
            return this;
        };
        this.setAddress = (address) => {
            if (!helpers_1.isEthereumAddress(address)) {
                throw Error(`address should be valid ethereum address: ${address}`);
            }
            this.address = address;
            return this;
        };
        this.setEmail = (email) => {
            this.email = email;
            return this;
        };
        this.setUserSignature = (sig, timestamp) => {
            if (!helpers_1.isSignature(sig)) {
                throw Error(`user signature is invalid: ${sig}`);
            }
            if (!timestamp) {
                throw Error(`user signature timestamp is invalid: ${timestamp}`);
            }
            this.userSignature = sig;
            this.userSignatureTimestamp = timestamp;
            return this;
        };
        this.setSilkeySignature = (sig, timestamp) => {
            if (!helpers_1.isSignature(sig)) {
                throw Error(`silkey signature is invalid: ${sig}`);
            }
            if (!timestamp) {
                throw Error(`silkey signature timestamp is invalid: ${timestamp}`);
            }
            this.silkeySignature = sig;
            this.silkeySignatureTimestamp = timestamp;
            return this;
        };
        /**
         * Creates message that's need to be sign by user
         *
         * @method
         *
         * @returns {string}
         */
        this.messageToSignByUser = () => {
            if (!this.address && !this.userSignatureTimestamp) {
                //this.userSignatureTimestamp = currentTimestamp()
            }
            const data = {
                'address': Buffer.concat([Buffer.from('address'), Buffer.from(helpers_1.remove0x(this.address.toLowerCase()), 'hex')]),
                'scope': Buffer.concat([Buffer.from('scope'), Buffer.from(this.scope)]),
                'migration': Buffer.concat([Buffer.from('migration'), Buffer.from(this.migration ? '01' : '00', 'hex')]),
                'userSignatureTimestamp': Buffer.concat([Buffer.from('userSignatureTimestamp'), helpers_1.intToBuffer(this.userSignatureTimestamp)])
            };
            return Buffer.concat(Object.keys(data).sort().map(k => {
                return data[k];
            })).toString('hex');
        };
        /**
         * Creates message that's need to be sign by Silkey
         *
         * @method
         *
         * @returns {string}
         */
        this.messageToSignBySilkey = () => {
            if (!this.email) {
                return '';
            }
            if (!this.silkeySignatureTimestamp) {
                this.silkeySignatureTimestamp = helpers_1.currentTimestamp();
            }
            return Buffer.concat([
                Buffer.from(this.email),
                helpers_1.intToBuffer(this.silkeySignatureTimestamp)
            ]).toString('hex');
        };
        this.validate = () => {
            if (!helpers_1.isEthereumAddress(this.address)) {
                throw new Error(`address is invalid: ${this.address}`);
            }
            if (!helpers_1.isSignature(this.userSignature)) {
                throw new Error(`userSignature is invalid: ${this.userSignature}`);
            }
            if (!helpers_1.isTimestamp(this.userSignatureTimestamp)) {
                throw new Error(`userSignatureTimestamp is invalid: ${this.userSignatureTimestamp}`);
            }
            if (!this.scope || this.scope === 'id') {
                return this;
            }
            if (!this.email) {
                throw new Error(`email is invalid: ${this.email}`);
            }
            if (!helpers_1.isSignature(this.silkeySignature)) {
                throw new Error(`silkeySignature is invalid: ${this.silkeySignature}`);
            }
            if (!helpers_1.isTimestamp(this.silkeySignatureTimestamp)) {
                throw new Error(`silkeySignatureTimestamp is invalid: ${this.silkeySignatureTimestamp}`);
            }
            return this;
        };
        this.export = () => {
            return JSON.parse(JSON.stringify(this));
        };
    }
}
exports.JwtPayload = JwtPayload;
JwtPayload.import = (obj = {}) => {
    return Object.assign(new JwtPayload(), obj instanceof JwtPayload ? obj.export() : obj);
};
//# sourceMappingURL=JwtPayload.js.map