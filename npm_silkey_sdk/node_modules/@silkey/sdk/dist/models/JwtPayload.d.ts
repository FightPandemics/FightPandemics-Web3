/**
 * @module JwtPayload
 */
import { JwtPayloadI, KeyValueI } from './';
/**
 * @typedef JwtPayload
 * @type {object}
 * @property {string} email - verified email of the user,
 *  IMPORTANT: if email in user profile is different, you should always update it with this one.
 * @property {string} address - ID of the user, this is also valid ethereum address, use this to identify user
 * @property {string} userSignature - proof that request came from the user
 * @property {number} userSignatureTimestamp - time when signature was crated
 * @property {string} silkeySignature - proof that Silkey verified the email
 * @property {number} silkeySignatureTimestamp - time when signature was crated
 * @property {string} scope
 * @property {boolean} migration - if user started migration to Silkey, this will be true
 */
export declare class JwtPayload implements JwtPayloadI {
    email: string;
    scope: string;
    address: string;
    silkeySignatureTimestamp: number;
    silkeySignature: string;
    userSignatureTimestamp: number;
    userSignature: string;
    migration: boolean;
    getScope: () => string[];
    setMigration: (status: boolean) => JwtPayload;
    setScope: (scope: string) => JwtPayload;
    setAddress: (address: string) => JwtPayload;
    setEmail: (email: string) => JwtPayload;
    setUserSignature: (sig: string, timestamp: number) => JwtPayload;
    setSilkeySignature: (sig: string, timestamp: number) => JwtPayload;
    /**
     * Creates message that's need to be sign by user
     *
     * @method
     *
     * @returns {string}
     */
    messageToSignByUser: () => string;
    /**
     * Creates message that's need to be sign by Silkey
     *
     * @method
     *
     * @returns {string}
     */
    messageToSignBySilkey: () => string;
    validate: () => JwtPayload;
    export: () => JwtPayloadI;
    static import: (obj?: JwtPayload | JwtPayloadI | KeyValueI) => JwtPayload;
}
//# sourceMappingURL=JwtPayload.d.ts.map