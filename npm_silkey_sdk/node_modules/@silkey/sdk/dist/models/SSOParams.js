"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SSOParams = void 0;
const helpers_1 = require("../utils/helpers");
const __1 = require("..");
const settings_1 = require("../config/settings"); // do not change path!
class SSOParams {
    constructor() {
        this.ssoTimestamp = 0;
        this.ssoRedirectUrl = '';
        this.ssoCancelUrl = '';
        this.ssoScope = settings_1.settings.ssoParams.DEFAULT_SCOPE;
        this.sign = async (signer) => {
            if (!helpers_1.isTimestamp(this.ssoTimestamp)) {
                this.ssoTimestamp = helpers_1.currentTimestamp();
            }
            this.ssoSignature = await signer.signMessage(__1.messageToSign(JSON.parse(JSON.stringify(this))));
            return this;
        };
        this.hasRequired = () => {
            if (!settings_1.settings.ssoParams.required.every(k => !!helpers_1.getKeyValue(this)(k))) {
                console.warn('This parameters are required for Silkey SSO:', settings_1.settings.ssoParams.required.join(', '));
                return false;
            }
            return true;
        };
        this.validate = () => {
            if (!this.hasRequired()) {
                throw Error(`This parameters are required for Silkey SSO: ${settings_1.settings.ssoParams.required.join(', ')}`);
            }
            return this;
        };
        this.export = () => {
            const exported = JSON.parse(JSON.stringify(this.validate()));
            return Object.keys(exported).reduce((acc, k) => {
                if (helpers_1.isSet(helpers_1.getKeyValue(exported)(k))) {
                    acc[k] = exported[k];
                }
                return acc;
            }, {});
        };
    }
}
exports.SSOParams = SSOParams;
SSOParams.import = (obj = {}) => {
    return Object.assign(new SSOParams(), obj instanceof SSOParams ? obj.export() : obj);
};
//# sourceMappingURL=SSOParams.js.map